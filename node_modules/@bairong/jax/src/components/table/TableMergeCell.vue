<template>
  <div>
    <table class="mytable" style="margin-bottom: -2px;">
      <tr>
        <th v-for="(cols,index) in columns" :width="cols.width" :key="index+1">{{ cols.title || '' }}</th>
      </tr>
      <tr class="rowHidden" v-if="index<1" v-for="(row, index) in groupData" :key="index+1">
        <td v-for="(column,cIndex) in columns" :key="cIndex+1" :rowspan="row[column.merge+'_column_'+cIndex]" v-if="row[column.merge+'_column_'+cIndex] != 0">
          <span v-if="String(row[column.key]).substr(0,1) == '<'" v-html="row[column.key]"></span>
          <span v-else-if="typeof row[column.key] === 'function'">
            <RunFunction style="height: 0px" :row="row" :column="column"  :index="0"  :render="row[column.key]"></RunFunction>
          </span>
          <span v-else-if="typeof column.render === 'function'">
            <RunFunction style="height: 0px" :row="row" :column="column"  :index="0"  :render="column.render"></RunFunction>
          </span>
          <span v-else >{{row[column.key]}}</span>
        </td>
      </tr>
      <tr v-if="!groupData || groupData.length === 0">
        <td style="text-align: center;" :colspan="columns.length">...</td>
      </tr>
    </table>
    <div v-if="groupData && groupData.length != 0" :style="{'max-height': height, 'overflow-y':'auto'}">
    <table class="mytable" style="margin-top: -3px;">
        <tr class="rowHidden">
          <th v-for="(cols,index) in columns" :width="cols.width" :key="index+1">{{ cols.title || '' }}</th>
        </tr>
        <tr v-for="(row, index) in groupData" :key="index+1">
        <td v-for="(column,cIndex) in columns" :key="cIndex+1" :rowspan="row[column.merge+'_column_'+cIndex]" v-if="row[column.merge+'_column_'+cIndex] != 0">
          <span v-if="String(row[column.key]).substr(0,1) == '<'" v-html="row[column.key]"></span>
          <span v-else-if="typeof row[column.key] === 'function'">
            <RunFunction :row="row" :column="column"  :index="index"  :render="row[column.key]"></RunFunction>
          </span>
          <span v-else-if="typeof column.render === 'function'">
            <RunFunction :row="row" :column="column"  :index="index"  :render="column.render"></RunFunction>
          </span>
          <span v-else >{{row[column.key]}}</span>
        </td>
      </tr>
    </table>
    </div>
  </div>
</template>
<script>
/**
 * 合并相邻的数据，根据列参数中配置的merge
 * 参数说明：
 * columns 列参数中包含 merge  如  {merge : "firstTypeRowSpan"}
 * data 数组数据按照 merge包含列，按照要合并的字段排序 。
 * height 默认不设置会根据内容高度显示表格高度;设置如300px给指定高度后，表格会自动固定表头,当纵向内容过多时显示滚动条。
 * 2019.3.1
 * hl
 */
import RunFunction from './runRender';
export default {
  name: 'TableMergeCell',
  components: {RunFunction},
  props: {columns: Array, data: Array, height: {default: 'auto'}},
  methods: {
    setData (rdata) {
      if (this.columns.length > 0) {
        for (var c = 0; c < this.columns.length; c++) {
          var row = this.columns[c];
          // row {merge : "firstTypeRowSpan"} 存在要合并该列下面的相同的多条数据为一个单元格，firstTypeRowSpan 做为数据源中的统计数量字段要不一定要唯一
          // 要求按照合并的数据排序，即 一样的数据上下相邻合并。
          if (row.hasOwnProperty('merge')) {
            var obj = {};
            for (var i = 0; i < rdata.length; i++) {
              var item = rdata[i];
              var celVal = typeof item[row.key] + item[row.key];
              if (obj[celVal] === undefined) {
                obj[celVal] = 1;
              } else {
                obj[celVal]++; // 要求数据相邻统计
              }
            }
            for (var j = 0; j < rdata.length; j++) {
              var itemO = this.data[j];
              for (var k in obj) {
                if (typeof itemO[row.key] + itemO[row.key] === k) { // obj中的key是字符类型
                  // console.log(itemO[row.key], typeof itemO[row.key], '  ==  ', k, typeof k, obj);
                  itemO[row.key + '_RowCount'] = obj[k];
                  break;
                }
              }
              if (itemO[row.key + '_RowCount'] > 1) {
                // console.log(66, itemO[row.key], '  ==  ', itemO[row.key + '_RowCount'], j, row);
                if (j === 0) {
                  itemO[row.merge + '_column_' + c] = itemO[row.key + '_RowCount'];
                } else if (itemO[row.key] === rdata[j - 1][row.key]) {
                  itemO[row.merge + '_column_' + c] = 0;
                } else {
                  itemO[row.merge + '_column_' + c] = itemO[row.key + '_RowCount'];
                }
              }
            }
          } // if (row.hasOwnProperty('merge')
        }
      }
      // this.data = rdata;
      return rdata;
    }
  },
  computed: {
    groupData: function () {
      return this.setData(this.data);
    }
  }
};
</script>
<style lang="less" scoped>
  table {
    border-collapse: collapse;
    border-spacing: 0;
  }

  .mytable {
    width: 100%;
    margin: 0;
    border-collapse: collapse;
    border-spacing: 0;
    empty-cells: show;
    border: 1px solid #dededf;
    thead, tbody {
      display: table-header-group;
      vertical-align: middle;
      border-color: inherit;
    }
    thead {
      width: 100%;
      background-color: #DDDEE2;
      tr {
        width: 100%;
      }
      th {
        padding: 12px 18px;
      }
    }
    tbody {
      width: 100%;
      tr {
        width: 100%;
        &:hover {
          background-color: #ebf7ff;
        }
      }
    }
    td {
      max-width: 400px;
      padding: 12px 18px;
      border: 1px solid #e9eaec;
      text-align: left;
    }

    th {
      background-color: #F0F1F5;
      padding: 12px 18px;
      text-align: left;
    }
    .rowHidden {
      line-height: 1px;
      height: 1px;
      visibility: hidden;
      th, td {
        visibility: hidden;
        line-height: 1px;
        padding: 0 18px;
        height: 1px;
        span {
          padding: 0 !important;
          margin: 0 !important;
          ul li {
            line-height: 0px;
            padding: 0 !important;
            margin: 0 !important;
          }
        }
      }
    }
  }
</style>
