/**
 * tools 集
 */

import moment from 'moment/moment';

const isObject = obj => Object.prototype.toString.call(obj) === '[object Object]';
const isArray = arr => Array.isArray(arr);

const emptyObj = (obj) => { // json 判断属性
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
};

const deepCopy = (o) => {
  if (o instanceof Array) {
    const n = [];
    for (let i = 0; i < o.length; ++i) {
      n[i] = deepCopy(o[i]);
    }
    return n;
  } else if (typeof o === 'function') {
    return o;
  } else if (o instanceof Object) {
    const n = {};
    let i;
    for (i in o) {
      n[i] = deepCopy(o[i]);
    }
    return n;
  } else {
    return o;
  }
};

/**
 * @public
 * @name formatDate
 * @param {date}
 * @param {string} rule 格式
 * @return {string}
 * @description 时间格式化
 */

const formatDate = (date, rule = 'YYYY-MM-DD') => {
  if (!date) return;
  if (typeof date === 'string') {
    date = date.trim();
  }
  var text = moment(date).format(rule);
  return text === 'Invalid date' ? date : text;
};

/**
 * @public
 * @name filterData
 * @param {obj, array} data
 * @param {fun} fun 过滤规则，需要去除的数据, 返回 boolean
 * @return {obj, array}
 * @description 数据过滤
 */

const filterData = (data = [], fun) => {
  let result = null;
  if (isArray(data)) {
    result = data.filter(item => fun(item));
  } else if (isObject(data)) {
    const keysArr = Object.keys(data);
    const keysFilter = keysArr.filter(key => fun(data[key]));

    result = {};
    for (let key of keysFilter) {
      result[key] = data[key];
    }
  } else {
    return new Error('data is object or array !');
  }

  return result;
};

/**
 * @public
 * @name download
 * @param {string} url
 * @param {string} filename
 * @description 模拟下载
 */

const download = (url = '', filename = 'file') => {
  let a = document.createElement('a');
  a.href = url.replace(/\/\//g, '/');
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
};

/**
 * @export
 * @param {any} JSONstr
 * @returns
 */
function preventJSONParse (JSONstr, initVal = {}) {
  return new Promise((resolve, reject) => {
    if (!JSONstr) {
      resolve(initVal);
    } else {
      try {
        const JSON_DATA = JSON.parse(JSONstr);
        resolve(JSON_DATA);
      } catch (err) {
        reject(err);
      }
    }
  });
}
/**
 * @param {any} obj
 * @param {any} props, props path
 * @param {string} [defaultValue='']
 * @returns
 */
function getObjKeyValByPath (obj, props, defaultValue = '-') {
  if (typeof props === 'string') {
    props = props.split('.');
  }

  if (typeof obj === 'undefined' || (!obj && typeof obj !== 'undefined' && obj !== 0)) {
    return defaultValue;
  }
  if (props.length === 0) {
    return obj;
  }

  var prop = props.shift();

  if (prop && obj.hasOwnProperty(prop)) {
    return getObjKeyValByPath(obj[prop], props, defaultValue);
  }

  return defaultValue;
}

export default {
  isObject,
  isArray,
  emptyObj,
  deepCopy,
  formatDate,
  filterData,
  download,
  preventJSONParse,
  getObjKeyValByPath
};
